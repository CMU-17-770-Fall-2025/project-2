// Copyright 2024 Wizard Authors. All rights reserved.
// See LICENSE for details of Apache 2.0 license.

def monitor_ = MonitorRegistry.add(
    "cache-sim", "Simulates a cache for a simple memory model.",
    CacheSimulationMonitor.new());


class CacheSimulationMonitor extends Monitor {
    // TODO: Monitor Implementation
}

/***** OUTPUT FORMATTING HELPER METHODS (Do not modify) *****/
/*
 * ***Output Format for Grading:***
 *
 * 1. **Function Header Output:**
 *    - Use the helper method `output_func_header()` to print each function's header.
 *    - The **function headers must be printed in increasing order of function index** 
 *      (e.g., Func[0], Func[1], Func[2], ...).
 *    - **Ensure** that the function header is printed **before** the corresponding cache statistics.
 *
 * 2. **CacheStat Output:**
 *    - After printing each function header, use the helper method `output_cache_stat()` 
 *      to print the cache statistics.
 *    - The **cache statistics must be printed in increasing order of the program counter (pc)** 
 *      for each function.
 *
 * ***Important Notes:***
 * - The **correct order of output** is essential for grading. 
 * - Output **must follow** the specified structure of increasing function index and program counter.
 * - Do not report unvisited functions or accesses>
 * - Do not invoke any output functions other than the methods specified above 
 * - **Double-check your output** to ensure it matches the expected format, as incorrect output will result in lost points.
 */

type CacheStat(hits: u64, misses: u64);

// Method to output function name
def output_func_header(module: Module, func: FuncDecl) {
    Trace.OUT.beginColor(Color.FUNC)
        .put1("func %q:", func.render(module.names, _))
        .endColors().ln();

}
// Method to output a single CacheStat
def output_cache_stat(pc: int, op_mnemonic: string, stat: CacheStat) {
    Trace.OUT.beginColor(Color.INACTIVE)
        .mark()
        .put1("+%d", pc)
        .rjustify_mark(5)
        .endColors()
        .putc(' ');

    Trace.OUT.beginColor(Color.SOURCE)
        .mark()
        .puts(op_mnemonic)
        .rjustify_mark(16)
        .putc(':')
        .putc(' ')
        .endColors();


    Trace.OUT.beginColor(Color.SUCCESS)
        .mark()
        .put1("%d", stat.hits)
        .rjustify_mark(6)
        .endColors()
        .putc(' ');
    Trace.OUT.beginColor(Color.HIGH)
        .mark()
        .put1("%d", stat.misses)
        .rjustify_mark(6)
        .endColors()
        .putc(' ')
        .ln();
}
/******************/
